<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aider Harness UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://unpkg.com/ansi_up@5.1.0/ansi_up.js"></script> <!-- Add ansi_up library -->
    <style>
        /* Basic styling */
        body { font-family: sans-serif; }
        .log-entry { white-space: pre-wrap; word-break: break-word; }
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="bg-gray-100 p-4" x-data="harnessUI()" x-cloak>

    <div class="container mx-auto bg-white p-6 rounded shadow-lg">
        <h1 class="text-2xl font-bold mb-4">Aider Harness Status</h1>

        <!-- Connection Status -->
        <div class="mb-4 p-2 rounded" :class="wsStatus === 'Connected' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'">
            WebSocket Status: <span x-text="wsStatus">Connecting...</span>
            <span x-show="wsStatus !== 'Connected' && wsStatus !== 'Error'" class="ml-2 text-sm">(Attempting to connect to ws://<span x-text="websocketHost"></span>:<span x-text="websocketPort"></span><span x-show="retrying">, retrying...</span>)</span>
            <span x-show="wsStatus === 'Error'" class="ml-2 text-sm">(Connection failed. Check console or server logs. Retrying...)</span>
        </div>

        <!-- Run Status -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div class="bg-blue-50 p-3 rounded">
                <strong>Run ID:</strong> <span x-text="status.run_id || 'N/A'"></span>
            </div>
            <div class="bg-blue-50 p-3 rounded">
                <strong>Iteration:</strong> <span x-text="status.iteration || '0'"></span>
            </div>
            <div class="bg-blue-50 p-3 rounded">
                <strong>Status:</strong> <span x-text="status.status || 'Idle'"></span>
            </div>
        </div>

        <!-- Live Aider Output -->
        <div class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Live Aider Output</h2>
            <!-- Use div with x-html to render ANSI codes processed by ansi_up -->
            <!-- Add error handling for ansi_up -->
            <div class="bg-gray-900 text-gray-300 p-4 rounded h-96 overflow-y-auto text-xs font-mono" x-ref="aiderLogContainer">
                <div class="log-entry" x-html="() => {
                    try {
                        // console.log('Rendering liveAiderOutput length:', liveAiderOutput.length); // Optional: log before render
                        return ansiUp ? ansiUp.ansi_to_html(liveAiderOutput) : liveAiderOutput;
                    } catch (e) {
                        console.error('AnsiUp conversion error:', e);
                        return `<span style=&quot;color: red; font-weight: bold;&quot;>Error rendering output: ${e.message}</span><br>${liveAiderOutput}`; // Show error and raw output
                    }
                }"></div>
            </div>
        </div>

        <!-- Log Output -->
        <div class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Live Log</h2>
            <div class="bg-gray-800 text-white p-4 rounded h-64 overflow-y-auto text-sm font-mono" x-ref="logContainer">
                <template x-for="(entry, index) in status.log" :key="index">
                    <div class="log-entry" x-text="entry"></div>
                </template>
            </div>
        </div>

        <!-- Interaction Area -->
        <div class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Interaction</h2>
            <div x-show="lastInterruptStatus" class="mb-2 p-2 bg-blue-100 text-blue-800 rounded">
                <strong>Last interrupt status:</strong> <span x-text="lastInterruptStatus"></span>
            </div>
            <textarea x-model="userInput" class="w-full p-2 border rounded mb-2" rows="3" placeholder="Provide guidance or ask Aider to change course..."></textarea>
            <div class="flex items-center justify-between">
                <div class="flex items-center">
                     <input type="checkbox" id="interrupt-checkbox" x-model="interruptAider" class="mr-2">
                     <label for="interrupt-checkbox" class="text-sm text-gray-700">Interrupt current Aider process</label>
                </div>
                <button @click="sendMessage" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:opacity-50" :disabled="!userInput.trim()">Send</button>
            </div>
            <p class="text-xs text-gray-500 mt-1">If unchecked, guidance will be added before the next iteration starts. If checked, the current Aider process will be stopped first.</p>
        </div>

    </div>

    <script>
        function harnessUI() {
            return {
                // Default host/port - should match config.yaml or be configurable
                websocketHost: 'localhost',
                websocketPort: 9940, // Updated default port
                ws: null,
                wsStatus: 'Connecting...',
                status: {
                    status: "Initializing",
                    run_id: null,
                    iteration: 0,
                    log: ["UI Initialized. Waiting for connection..."]
                },
                retryTimeout: null,
                retrying: false, // Flag to indicate if a retry is scheduled
                userInput: '', // For the textarea
                interruptAider: false, // For the checkbox
                liveAiderOutput: '', // Raw Aider output with ANSI codes
                outputBuffer: '', // Buffer for incoming chunks
                isProcessingScheduled: false, // Flag for debouncing
                lastInterruptStatus: '', // To store the status of the last interrupt request
                ansiUp: null, // To hold the ansi_up instance
                lastLogEntry: null, // Track last log entry to prevent duplicates

                init() {
                    console.log('Initializing Harness UI...');
                    this.ansiUp = new AnsiUp(); // Initialize ansi_up
                    this.connectWebSocket();
                },

                connectWebSocket() {
                    const wsUrl = `ws://${this.websocketHost}:${this.websocketPort}`;
                    console.log(`Attempting to connect to ${wsUrl}`);
                    this.wsStatus = 'Connecting...';
                    this.status.log.push(`Attempting connection to ${wsUrl}...`);

                    // Clear previous timeout if exists
                    if (this.retryTimeout) clearTimeout(this.retryTimeout);

                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.wsStatus = 'Connected';
                        this.status.log.push('WebSocket connection established.');
                        this.retrying = false; // Reset retry flag
                        // Reset retry timeout on successful connection
                        if (this.retryTimeout) {
                            clearTimeout(this.retryTimeout);
                            this.retryTimeout = null;
                        }
                    };

                    this.ws.onmessage = (event) => {
                        // console.log('Raw WS Message:', event.data); // Log raw data if needed
                        try {
                            const data = JSON.parse(event.data);
                            console.log("Parsed WS data:", data); // <-- Log parsed data

                            // Check message type
                            if (data.type === 'aider_output') {
                                // Buffer the chunk and schedule processing
                                if (data.chunk) {
                                    this.outputBuffer += data.chunk;
                                    if (!this.isProcessingScheduled) {
                                        this.isProcessingScheduled = true;
                                        requestAnimationFrame(() => this.processOutputBuffer());
                                    }
                                }
                            } else if (data.type === 'aider_output_clear') {
                                this.liveAiderOutput = ''; // Clear the raw output
                                this.outputBuffer = ''; // Also clear the buffer
                            } else if (data.type === 'interrupt_ack') {
                                // Handle interrupt acknowledgment
                                this.lastInterruptStatus = data.message;
                                this.status.log.push(`Interrupt status: ${data.message}`);
                                // Show a notification to the user
                                const interruptType = data.interrupt_now ? 'immediate' : 'scheduled';
                                this.showNotification(`Interrupt ${interruptType}: ${data.message}`);
                            } else {
                                // Assume it's a general status update
                                this.status = { ...this.status, ...data }; // Merge new data
                                // Ensure log is always an array
                                if (!Array.isArray(this.status.log)) {
                                    this.status.log = [JSON.stringify(this.status.log)];
                                }
                                // Ensure log is always an array
                                if (!Array.isArray(this.status.log)) {
                                    this.status.log = [JSON.stringify(this.status.log)];
                                }
                                // Prevent adding duplicate consecutive log entries
                                const newLogEntry = data.log_entry; // Check if log_entry exists in the update
                                if (newLogEntry && newLogEntry !== this.lastLogEntry) {
                                    // Note: The backend already limits the log array size.
                                    // We just prevent adding duplicates here.
                                    // The backend update logic merges 'log_entry' into the 'log' array.
                                    this.lastLogEntry = newLogEntry;
                                } else if (newLogEntry) {
                                     console.log("Skipping duplicate log entry:", newLogEntry);
                                     // Remove the duplicate log_entry from the received data
                                     // before merging, so it doesn't overwrite status.log
                                     delete data.log_entry;
                                }

                                // Merge new data (potentially without duplicate log_entry)
                                this.status = { ...this.status, ...data };

                                // Scroll main log container to bottom
                                this.$nextTick(() => { // Ensure DOM is updated before scrolling
                                    this.scrollToBottom('logContainer');
                                });
                            }
                        } catch (e) {
                            console.error('Failed to parse message:', e);
                            this.status.log.push(`Error parsing message: ${event.data}`);
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.wsStatus = 'Error';
                        this.status.log.push(`WebSocket error occurred. Check console or server logs.`);
                        // Attempt to reconnect after a delay only if not already retrying
                        if (!this.retrying) {
                            this.scheduleReconnect();
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket disconnected:', event.code, event.reason);
                        // Avoid showing 'Disconnected' if an error already occurred and is triggering reconnect
                        if (this.wsStatus !== 'Error') {
                             this.wsStatus = `Disconnected (Code: ${event.code})`;
                        }
                        this.status.log.push(`WebSocket disconnected (Code: ${event.code}, Reason: ${event.reason || 'N/A'}). Attempting to reconnect...`);
                        // Attempt to reconnect only if not already retrying
                        if (!this.retrying) {
                            this.scheduleReconnect();
                        }
                    };
                },

                scheduleReconnect() {
                    // Don't schedule if already scheduled/retrying
                    if (this.retrying || this.retryTimeout) return;

                    this.retrying = true; // Set retry flag
                    const delay = 5000; // 5 seconds
                    this.status.log.push(`Scheduling WebSocket reconnect in ${delay / 1000} seconds...`);
                    console.log(`Scheduling WebSocket reconnect in ${delay / 1000} seconds...`);
                    
                    this.retryTimeout = setTimeout(() => {
                        this.retryTimeout = null; // Clear the timeout ID
                        this.retrying = false; // Clear the flag before attempting connection
                        // Only attempt reconnect if not already connected
                        if (this.wsStatus !== 'Connected') {
                             this.connectWebSocket();
                        }
                    }, delay);
                },

                sendMessage() {
                    if (!this.userInput.trim()) return; // Don't send empty messages

                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        const messagePayload = {
                            command: 'interrupt', // Use the 'interrupt' command
                            message: this.userInput,
                            interrupt_now: this.interruptAider // Send checkbox state
                        };
                        console.log('Sending message:', messagePayload);
                        this.ws.send(JSON.stringify(messagePayload));
                        this.status.log.push(`Sent guidance (Interrupt: ${this.interruptAider}): ${this.userInput.substring(0, 50)}...`);
                        this.userInput = ''; // Clear input after sending
                        // Optionally uncheck interrupt after sending? User might want it checked for next message.
                        // this.interruptAider = false;
                    } else {
                        console.error('WebSocket not connected. Cannot send message.');
                        this.status.log.push('Error: WebSocket not connected. Cannot send guidance.');
                    }
                },

                // Removed processedAiderOutput() function, logic moved directly into x-html

                scrollToBottom(refName) {
                    // Scroll the specified container to the bottom
                    if (this.$refs[refName]) {
                        const container = this.$refs[refName];
                        container.scrollTop = container.scrollHeight;
                    }
                },
                
                showNotification(message) {
                    // Simple notification function
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    notification.textContent = message;
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        notification.classList.add('opacity-0', 'transition-opacity', 'duration-500');
                        setTimeout(() => {
                            document.body.removeChild(notification);
                        }, 500);
                    }, 3000);
                },

                // Removed processAiderChunk function

                processOutputBuffer() {
                    if (this.outputBuffer === '') {
                        this.isProcessingScheduled = false;
                        return; // Nothing to process
                    }

                    const bufferToProcess = this.outputBuffer;
                    this.outputBuffer = ''; // Clear buffer before processing
                    console.log("Processing buffer content:", bufferToProcess); // <-- Log buffer content

                    // Directly append the raw buffer content to liveAiderOutput
                    // Let ansi_up handle the conversion in the x-html directive
                    this.liveAiderOutput += bufferToProcess;
                    console.log("After appending buffer. New liveAiderOutput length:", this.liveAiderOutput.length); // <-- Log updated length

                    // Limit scrollback after appending and before rendering
                    const lines = this.liveAiderOutput.split('\n');
                    const maxLines = 10000; // Keep the limit
                    if (lines.length > maxLines) {
                        this.liveAiderOutput = lines.slice(-maxLines).join('\n');
                    }

                    // Use nextTick to ensure DOM updates before scrolling
                    this.$nextTick(() => {
                        this.scrollToBottom('aiderLogContainer');
                    });

                    // Check if new data arrived while processing
                    if (this.outputBuffer !== '') {
                        // Reschedule immediately if buffer has new content
                        requestAnimationFrame(() => this.processOutputBuffer());
                    } else {
                        this.isProcessingScheduled = false; // Allow new scheduling
                    }
                }
            }
        }
    </script>

</body>
</html>
