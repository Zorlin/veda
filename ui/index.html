<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aider Harness UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- ansi-to-html (browser-compatible UMD build) -->
    <script src="https://cdn.jsdelivr.net/npm/ansi-to-html@0.7.1/dist/ansi_to_html.min.js"></script>
    <!-- Prism.js for Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <!-- Add diff language support explicitly if autoloader doesn't pick it up -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-diff.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/keep-markup/prism-keep-markup.min.js"></script> <!-- Keep HTML markup within code blocks -->


    <style>
        /* Basic styling */
        body { font-family: sans-serif; }
        .log-entry { white-space: pre-wrap; word-break: break-word; }
        [x-cloak] { display: none !important; }
    </style>
</head>
<body class="bg-gray-100 p-4" x-data="harnessUI()" x-cloak>

    <div class="container mx-auto bg-white p-6 rounded shadow-lg">
        <h1 class="text-2xl font-bold mb-4">Aider Harness Status</h1>

        <!-- Connection Status -->
        <div class="mb-4 p-2 rounded" :class="wsStatus === 'Connected' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'">
            WebSocket Status: <span x-text="wsStatus">Connecting...</span>
            <span x-show="wsStatus !== 'Connected' && wsStatus !== 'Error'" class="ml-2 text-sm">(Attempting to connect to ws://<span x-text="websocketHost"></span>:<span x-text="websocketPort"></span><span x-show="retrying">, retrying...</span>)</span>
            <span x-show="wsStatus === 'Error'" class="ml-2 text-sm">(Connection failed. Check console or server logs. Retrying...)</span>
        </div>

        <!-- Run Status -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div class="bg-blue-50 p-3 rounded">
                <strong>Run ID:</strong> <span x-text="status.run_id || 'N/A'"></span>
            </div>
            <div class="bg-blue-50 p-3 rounded">
                <strong>Iteration:</strong> <span x-text="status.iteration || '0'"></span>
            </div>
            <div class="bg-blue-50 p-3 rounded">
                <strong>Status:</strong> <span x-text="status.status || 'Idle'"></span>
            </div>
        </div>

        <!-- Iteration Results -->
        <div class="mb-4 border border-gray-200 p-4 rounded bg-gray-50" x-show="status.verdict">
             <h2 class="text-xl font-semibold mb-2">Last Iteration Results</h2>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-3">
                 <div class="bg-indigo-50 p-3 rounded">
                     <strong>Verdict:</strong> <span x-text="status.verdict || 'N/A'"></span>
                 </div>
                 <div class="bg-indigo-50 p-3 rounded">
                     <strong>Suggestions:</strong> <span x-text="status.suggestions || 'N/A'"></span>
                 </div>
             </div>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                 <div>
                     <h3 class="text-lg font-medium mb-1">Aider Diff</h3>
                     <!-- Add language-diff class and wrap content in <code> for Prism.js -->
                     <pre class="bg-gray-900 text-gray-300 p-3 rounded h-48 overflow-y-auto text-xs font-mono language-diff" x-ref="diffViewer"><code x-text="status.aider_diff || '[No diff]'"></code></pre>
                 </div>
                 <div>
                     <h3 class="text-lg font-medium mb-1">Pytest Output</h3>
                     <pre class="bg-gray-900 text-gray-300 p-3 rounded h-48 overflow-y-auto text-xs font-mono" x-text="status.pytest_output || '[No output]'"></pre>
                 </div>
             </div>
        </div>


        <!-- Live Aider Output -->
        <div class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Live Aider Output / Current Task</h2>
            <!-- Use div with x-html to render ANSI codes processed by ansi_up -->
            <!-- Add error handling for ansi_up -->
            <div class="bg-gray-900 text-gray-300 p-4 rounded h-64 overflow-y-auto text-xs font-mono" x-ref="aiderLogContainer">
                <div class="log-entry" x-html="() => {
                    try {
                        // console.log('Rendering liveAiderOutput length:', liveAiderOutput.length); // Optional: log before render
                        return ansiConverter ? ansiConverter.toHtml(liveAiderOutput) : liveAiderOutput;
                    } catch (e) {
                        console.error('ansi-to-html conversion error:', e);
                        return `<span style=&quot;color: red; font-weight: bold;&quot;>Error rendering output: ${e.message}</span><br>${liveAiderOutput}`; // Show error and raw output
                    }
                }"></div>
            </div>
        </div>

        <!-- Log Output -->
        <div class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Live Log</h2>
            <div class="bg-gray-800 text-white p-4 rounded h-64 overflow-y-auto text-sm font-mono" x-ref="logContainer">
                <template x-for="(entry, index) in status.log" :key="index">
                    <div class="log-entry" x-text="entry"></div>
                </template>
            </div>
        </div>

        <!-- Interaction Area -->
        <div class="mb-4">
            <h2 class="text-xl font-semibold mb-2">Interaction</h2>
            <div x-show="lastInterruptStatus" class="mb-2 p-2 bg-blue-100 text-blue-800 rounded">
                <strong>Last interrupt status:</strong> <span x-text="lastInterruptStatus"></span>
            </div>
            <textarea x-model="userInput" class="w-full p-2 border rounded mb-2" rows="3" placeholder="Provide guidance or ask Aider to change course..."></textarea>
            <div class="flex items-center justify-between">
                <div class="flex items-center">
                     <input type="checkbox" id="interrupt-checkbox" x-model="interruptAider" class="mr-2">
                     <label for="interrupt-checkbox" class="text-sm text-gray-700">Interrupt current Aider process</label>
                </div>
                <button @click="sendMessage" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:opacity-50" :disabled="!userInput.trim()">Send</button>
            </div>
            <p class="text-xs text-gray-500 mt-1">If unchecked, guidance will be added before the next iteration starts. If checked, the current Aider process will be stopped first.</p>
        </div>

    </div>

    <script>
        function harnessUI() {
            return {
                // Default host/port - should match config.yaml or be configurable
                websocketHost: 'localhost',
                websocketPort: 9940, // Updated default port
                ws: null,
                wsStatus: 'Connecting...',
                status: {
                    status: "Initializing",
                    run_id: null,
                    iteration: 0,
                    log: ["UI Initialized. Waiting for connection..."],
                    aider_diff: '',
                    pytest_output: '',
                    verdict: '',
                    suggestions: ''
                },
                retryTimeout: null,
                retrying: false, // Flag to indicate if a retry is scheduled
                userInput: '', // For the textarea
                interruptAider: false, // For the checkbox
                liveAiderOutput: '', // Raw Aider output with ANSI codes
                outputBuffer: '', // Buffer for incoming chunks
                isProcessingScheduled: false, // Flag for debouncing
                lastInterruptStatus: '', // To store the status of the last interrupt request
                ansiConverter: null, // To hold the ansi-to-html instance
                lastLogEntry: null, // Track last log entry to prevent duplicates
                lastProcessedChunk: '', // Track the last processed aider output chunk to prevent duplicates

                init() {
                    console.log('Initializing Harness UI...');
                    // Initialize ansi-to-html with desired options (e.g., handle newlines)
                    this.ansiConverter = new AnsiToHtml({ newline: true, escapeXML: true }); 
                    this.connectWebSocket();
                },

                connectWebSocket() {
                    const wsUrl = `ws://${this.websocketHost}:${this.websocketPort}`;
                    console.log(`Attempting to connect to ${wsUrl}`);
                    this.wsStatus = 'Connecting...';
                    this.status.log.push(`Attempting connection to ${wsUrl}...`);

                    // Clear previous timeout if exists
                    if (this.retryTimeout) clearTimeout(this.retryTimeout);

                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.wsStatus = 'Connected';
                        this.status.log.push('WebSocket connection established.');
                        this.retrying = false; // Reset retry flag
                        // Reset retry timeout on successful connection
                        if (this.retryTimeout) {
                            clearTimeout(this.retryTimeout);
                            this.retryTimeout = null;
                        }
                    };

                    this.ws.onmessage = (event) => {
                        // console.log('Raw WS Message:', event.data); // Log raw data if needed
                        try {
                            const data = JSON.parse(event.data);
                            console.log("Parsed WS data:", data); // <-- Log parsed data

                            // Check message type
                            if (data.type === 'aider_output') {
                                // Buffer the chunk and schedule processing
                                if (data.chunk) {
                                    this.outputBuffer += data.chunk;
                                    if (!this.isProcessingScheduled) {
                                        this.isProcessingScheduled = true;
                                        requestAnimationFrame(() => this.processOutputBuffer());
                                    }
                                }
                            } else if (data.type === 'aider_output_clear') {
                                this.liveAiderOutput = ''; // Clear the raw output
                                this.outputBuffer = ''; // Also clear the buffer
                            } else if (data.type === 'interrupt_ack') {
                                // Handle interrupt acknowledgment
                                this.lastInterruptStatus = data.message;
                                this.status.log.push(`Interrupt status: ${data.message}`);
                                // Show a notification to the user
                                const interruptType = data.interrupt_now ? 'immediate' : 'scheduled';
                                this.showNotification(`Interrupt ${interruptType}: ${data.message}`);
                            } else {
                                // Assume it's a general status update
                                this.status = { ...this.status, ...data }; // Merge new data
                                // Ensure log is always an array
                                if (!Array.isArray(this.status.log)) {
                                    this.status.log = [JSON.stringify(this.status.log)];
                                }
                                // Ensure log is always an array
                                if (!Array.isArray(this.status.log)) {
                                    this.status.log = [JSON.stringify(this.status.log)];
                                }
                                // Prevent adding duplicate consecutive log entries
                                const newLogEntry = data.log_entry; // Check if log_entry exists in the update
                                if (newLogEntry && newLogEntry !== this.lastLogEntry) {
                                    // Note: The backend already limits the log array size.
                                    // We just prevent adding duplicates here.
                                    // The backend update logic merges 'log_entry' into the 'log' array.
                                    this.lastLogEntry = newLogEntry;
                                } else if (newLogEntry) {
                                     console.log("Skipping duplicate log entry:", newLogEntry);
                                     // Remove the duplicate log_entry from the received data
                                     // before merging, so it doesn't overwrite status.log
                                     delete data.log_entry;
                                }

                                // Merge new data (potentially without duplicate log_entry)
                                const previousDiff = this.status.aider_diff; // Store previous diff
                                this.status = { ...this.status, ...data };

                                // Limit the size of the status.log array
                                const maxLogEntries = 200; // Keep the last 200 entries
                                if (this.status.log.length > maxLogEntries) {
                                    // console.log(`Trimming status.log from ${this.status.log.length} to ${maxLogEntries} entries.`); // Optional: log trimming
                                    this.status.log = this.status.log.slice(-maxLogEntries);
                                }

                                // Scroll main log container to bottom
                                this.$nextTick(() => {
                                    this.scrollToBottom('logContainer');
                                    // Highlight diff if it changed
                                    if (this.status.aider_diff !== previousDiff && this.$refs.diffViewer && this.$refs.diffViewer.children.length > 0) {
                                        // console.log("Diff changed, highlighting..."); // Optional log
                                        Prism.highlightElement(this.$refs.diffViewer.children[0]); // Highlight the <code> element
                                    }
                                });
                            }
                        } catch (e) {
                            console.error('Failed to parse message:', e);
                            this.status.log.push(`Error parsing message: ${event.data}`);
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.wsStatus = 'Error';
                        this.status.log.push(`WebSocket error occurred. Check console or server logs.`);
                        // Attempt to reconnect after a delay only if not already retrying
                        if (!this.retrying) {
                            this.scheduleReconnect();
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket disconnected:', event.code, event.reason);
                        // Avoid showing 'Disconnected' if an error already occurred and is triggering reconnect
                        if (this.wsStatus !== 'Error') {
                             this.wsStatus = `Disconnected (Code: ${event.code})`;
                        }
                        this.status.log.push(`WebSocket disconnected (Code: ${event.code}, Reason: ${event.reason || 'N/A'}). Attempting to reconnect...`);
                        // Attempt to reconnect only if not already retrying
                        if (!this.retrying) {
                            this.scheduleReconnect();
                        }
                    };
                },

                scheduleReconnect() {
                    // Don't schedule if already scheduled/retrying
                    if (this.retrying || this.retryTimeout) return;

                    this.retrying = true; // Set retry flag
                    const delay = 5000; // 5 seconds
                    this.status.log.push(`Scheduling WebSocket reconnect in ${delay / 1000} seconds...`);
                    console.log(`Scheduling WebSocket reconnect in ${delay / 1000} seconds...`);
                    
                    this.retryTimeout = setTimeout(() => {
                        this.retryTimeout = null; // Clear the timeout ID
                        this.retrying = false; // Clear the flag before attempting connection
                        // Only attempt reconnect if not already connected
                        if (this.wsStatus !== 'Connected') {
                             this.connectWebSocket();
                        }
                    }, delay);
                },

                sendMessage() {
                    if (!this.userInput.trim()) return; // Don't send empty messages

                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        const messagePayload = {
                            command: 'interrupt', // Use the 'interrupt' command
                            message: this.userInput,
                            interrupt_now: this.interruptAider // Send checkbox state
                        };
                        console.log('Sending message:', messagePayload);
                        this.ws.send(JSON.stringify(messagePayload));
                        this.status.log.push(`Sent guidance (Interrupt: ${this.interruptAider}): ${this.userInput.substring(0, 50)}...`);
                        this.userInput = ''; // Clear input after sending
                        
                        // Show notification about the action taken
                        if (this.interruptAider) {
                            this.showNotification("Interrupting current Aider process and sending guidance");
                        } else {
                            this.showNotification("Guidance queued for next iteration");
                        }
                        
                        // Optionally uncheck interrupt after sending? User might want it checked for next message.
                        // this.interruptAider = false;
                    } else {
                        console.error('WebSocket not connected. Cannot send message.');
                        this.status.log.push('Error: WebSocket not connected. Cannot send guidance.');
                        this.showNotification("Error: WebSocket not connected", "error");
                    }
                },

                // Removed processedAiderOutput() function, logic moved directly into x-html

                scrollToBottom(refName) {
                    // Scroll the specified container to the bottom
                    if (this.$refs[refName]) {
                        const container = this.$refs[refName];
                        container.scrollTop = container.scrollHeight;
                    }
                },
                
                showNotification(message) {
                    // Simple notification function
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded shadow-lg z-50';
                    notification.textContent = message;
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        notification.classList.add('opacity-0', 'transition-opacity', 'duration-500');
                        setTimeout(() => {
                            document.body.removeChild(notification);
                        }, 500);
                    }, 3000);
                },

                showNotification(message, type = "info") {
                    // Simple notification function
                    const notification = document.createElement('div');
                    notification.className = `fixed top-4 right-4 ${type === "error" ? "bg-red-500" : "bg-blue-500"} text-white px-4 py-2 rounded shadow-lg z-50`;
                    notification.textContent = message;
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        notification.classList.add('opacity-0', 'transition-opacity', 'duration-500');
                        setTimeout(() => {
                            document.body.removeChild(notification);
                        }, 500);
                    }, 3000);
                },

                processOutputBuffer() {
                    if (this.outputBuffer === '') {
                        this.isProcessingScheduled = false;
                        return; // Nothing to process
                    }

                    const bufferToProcess = this.outputBuffer;
                    this.outputBuffer = ''; // Clear buffer before processing

                    // Prevent processing if the chunk is identical to the last one
                    if (bufferToProcess === this.lastProcessedChunk) {
                        console.log("Skipping duplicate chunk processing:", bufferToProcess.substring(0, 50) + "...");
                        // Reschedule if new data arrived while skipping
                        if (this.outputBuffer !== '') {
                            requestAnimationFrame(() => this.processOutputBuffer());
                        } else {
                            this.isProcessingScheduled = false;
                        }
                        return; // Don't process this duplicate chunk
                    }

                    console.log("Processing buffer content:", bufferToProcess.substring(0, 100) + (bufferToProcess.length > 100 ? "..." : "")); // Log start of buffer
                    this.lastProcessedChunk = bufferToProcess; // Store raw chunk

                    // --- Process buffer for control codes (\r, \b, \c) ---
                    let currentOutput = this.liveAiderOutput; // Get current state
                    let i = 0;
                    while (i < bufferToProcess.length) {
                        // Check for Aider's cancel code '\c' (represented as a single character or literal string)
                        if (
                            bufferToProcess[i] === '\u0003' || // Ctrl-C (ETX)
                            bufferToProcess.substring(i, i+2) === '\\c' // Literal \c
                        ) {
                            // Cancel code detected - clear the current line
                            const lastNewline = currentOutput.lastIndexOf('\n');
                            if (lastNewline !== -1) {
                                currentOutput = currentOutput.substring(0, lastNewline + 1);
                                // Add a visual indicator that cancellation occurred
                                currentOutput += '[AIDER CANCELLED]\n';
                            } else {
                                currentOutput = '[AIDER CANCELLED]\n'; // If no newline, clear everything
                            }
                            // Skip the cancel code (either 1 or 2 chars depending on representation)
                            i += (bufferToProcess[i] === '\u0003') ? 1 : 2;
                            
                            // Send notification to user about cancellation
                            this.showNotification("Aider operation cancelled");
                            continue;
                        }
                        // Check for other Aider control codes
                        else if (bufferToProcess.substring(i, i+2) === '\\q') {
                            // Quit code detected
                            currentOutput += '[AIDER QUIT]\n';
                            i += 2;
                            this.showNotification("Aider quit requested");
                            continue;
                        }
                        else if (bufferToProcess.substring(i, i+2) === '\\e') {
                            // Edit code detected
                            currentOutput += '[AIDER EDIT MODE]\n';
                            i += 2;
                            this.showNotification("Aider edit mode activated");
                            continue;
                        }
                        else if (bufferToProcess.substring(i, i+2) === '\\d') {
                            // Diff code detected
                            currentOutput += '[AIDER DIFF VIEW]\n';
                            i += 2;
                            this.showNotification("Aider diff view requested");
                            continue;
                        }
                        else if (bufferToProcess.substring(i, i+2) === '\\h') {
                            // Help code detected
                            currentOutput += '[AIDER HELP]\n';
                            i += 2;
                            this.showNotification("Aider help requested");
                            continue;
                        }
                        // Handle carriage return
                        else if (bufferToProcess[i] === '\r') {
                            // Carriage Return: Find last newline and discard text after it
                            const lastNewline = currentOutput.lastIndexOf('\n');
                            if (lastNewline !== -1) {
                                currentOutput = currentOutput.substring(0, lastNewline + 1);
                            } else {
                                currentOutput = ''; // If no newline, clear everything
                            }
                        } 
                        // Handle backspace
                        else if (bufferToProcess[i] === '\b') {
                            // Backspace: Remove last character if output is not empty
                            if (currentOutput.length > 0) {
                                currentOutput = currentOutput.slice(0, -1);
                            }
                        } 
                        // Normal character
                        else {
                            // Append normal characters
                            currentOutput += bufferToProcess[i];
                        }
                        i++; // Move to next character
                    }
                    this.liveAiderOutput = currentOutput; // Update the state
                    // --- End Control Code Processing ---


                    // Apply scrollback limit after processing
                    const maxLines = 10000; // Limit to 10,000 lines to prevent browser crashes
                    // Split by newline to estimate lines for scrollback limit
                    const lines = this.liveAiderOutput.split('\n');
                    if (lines.length > maxLines) {
                        // Find the index to slice from to keep maxLines
                        const startIndex = lines.length - maxLines;
                        // Rejoin the necessary lines. Note: This might split ANSI sequences,
                        // but it's a necessary tradeoff for scrollback limiting.
                        // ansi_up should hopefully handle broken sequences gracefully.
                        this.liveAiderOutput = lines.slice(startIndex).join('\n');
                        console.log(`Scrollback limited: removed ${startIndex} lines to keep under ${maxLines} line limit`);
                        // Show notification about scrollback limit
                        this.showNotification(`Scrollback limited to ${maxLines} lines`);
                    }
                    // --- End Simplified Processing ---

                    console.log("After appending buffer. New liveAiderOutput length:", this.liveAiderOutput.length); // <-- Log updated length

                    // Use nextTick to ensure DOM updates before scrolling
                    this.$nextTick(() => {
                        this.scrollToBottom('aiderLogContainer');
                    });

                    // Check if new data arrived while processing
                    if (this.outputBuffer !== '') {
                        // Reschedule immediately if buffer has new content
                        requestAnimationFrame(() => this.processOutputBuffer());
                    } else {
                        this.isProcessingScheduled = false; // Allow new scheduling
                    }
                }
            }
        }
    </script>

</body>
</html>
