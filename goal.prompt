## Goal: Ensure Aiderbot is Rock-Solid Reliable

**Overall Direction:** Our priority has shifted from initial development to ensuring Aiderbot is exceptionally reliable and performs consistently well under various conditions. We want users to be confident in Aiderbot's stability and performance.

**Key Objectives:**

*   **Proactive Testing:**  Conduct thorough stress testing to identify and fix any weaknesses *before* users encounter them. This includes testing with unusual data, under high load, and in scenarios that mimic real-world use cases.
*   **Graceful Handling of Errors:**  Ensure Aiderbot recovers smoothly from errors and provides clear, helpful messages to the user, minimizing frustration.
*   **Continuous Improvement:** Leverage Aiderbotâ€™s ability to learn from testing to proactively identify and address potential issues.
*   **Maintain a User-Centric Approach:** Every change and improvement should be evaluated for its impact on the user experience, focusing on ease of use and confidence.

**Next Steps:**

1.  **Execute comprehensive stress testing:**  Focus on edge cases and unusual scenarios.
2.  **Develop robust error handling mechanisms:**  Prioritize clear communication with the user.
3.  **Analyze testing results:**  Identify patterns and areas for improvement.
4.  **Iterate on design and implementation:**  Address identified weaknesses and enhance the user experience.

**Constraints (Refer to README.md for full details):**

*   Adhere to all previously defined high-level goals and limitations.
*   Maintain code quality and test coverage.
*   Prioritize user privacy and security.

---

### Implementation Directives

You are improving aiderbot according to the information laid out in README.md.

- Look for anything missing, any tests that can be added, anything you can do to make it run unstoppably and controllably.
- Expand on the concepts used if needed.
- ALL FUNCTIONALITY SHOULD HAVE EXTENSIVE TESTS.

#### Special Handling for Test Failures

If aiderbot detects a failed test (bad cargo test or pytest), it must:
- Modify the goal before the next iteration starts to specifically instruct the model to run `cargo test` (or the relevant test command for the failure).
- Clearly annotate the goal with the reason for the update and the specific test failure encountered.
- Ensure that the updated goal is used in the *very next* iteration, not delayed.

#### Conceptual Expansion

- The harness should be self-healing, able to recover from failures at every layer (subprocess, config, UI, ledger, etc.), and continue operation with minimal human intervention.
- It should dynamically adapt to changes in the goal prompt or configuration, applying them immediately to allow the agent to evolve its behavior on the fly.
- All subprocesses (Aider, Ollama, Pytest) must be managed with robust signal handling and resource cleanup, ensuring that interrupts are always effective and no zombie processes remain.
- The VESPER.MIND council provides multi-perspective evaluation, reducing the risk of tunnel vision or single-point failure in judgment.
- Both backend and frontend logic must prevent duplicate output, keeping logs and diffs concise and relevant, and ensuring the UI remains performant and user-friendly.
- Strict scrollback limits must be enforced to prevent memory leaks and browser crashes, even under high-throughput output scenarios.
- The architecture should be extensible, supporting new council roles, agent slots, or UI modalities (TUI, CLI, web) with minimal changes to the core logic.

#### You should:

1. Make Live Aider Output respect Aider's control codes (like \c for cancel)
2. Prevent text duplication in both the Live Log and Diff Viewers
3. Keep the Live Log focused on current state and recent activity
4. Implement a working interrupt system that actually stops Aider
5. Respect changes to goal.prompt even after initial run if they're edited

#### You should make sure:

- All output follows proper formatting control codes
- Diffs are displayed with clear syntax highlighting
- The Live Log only shows relevant, non-duplicated activity
- Interrupt process sends proper signals and cleans up resources
- Goal changes trigger reinitialization of Aider with new instructions
