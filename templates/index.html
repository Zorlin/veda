{% extends "base.html" %}

{% block content %}
{# Main Page Header #}
<div class="mb-8">
    <h1 class="text-4xl font-bold text-gray-800 mb-2">{{ title }}</h1>
    <p class="text-lg text-gray-600">Welcome to the Veda Web Interface. Define your goals and monitor progress here.</p>
</div>

{# Grid Layout for Sections #}
<div class="grid grid-cols-1 md:grid-cols-2 gap-6">

    {# Left Column #}
    <div class="space-y-6">

        {# Goal Definition Section #}
        <div class="bg-white rounded-lg shadow-md p-6" x-data="goalTagApp()">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700 border-b pb-2">Define Goal</h2>
            <p class="text-sm text-gray-600 mb-4">Add short goal fragments or tasks below. Drag to reorder, then synthesize into a full goal.</p>

            <div class="flex mb-4">
                <input type="text" x-model="newTagInput" @keydown.enter.prevent="addTag()"
                       placeholder="Add a goal fragment..."
                       class="flex-grow border border-gray-300 rounded-l-md p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                <button @click="addTag()"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-r-md text-sm transition duration-150 ease-in-out disabled:opacity-50"
                        :disabled="!newTagInput.trim()">
                    Add Tag
                </button>
            </div>

            <div x-ref="tagList" class="mb-4 space-y-2 min-h-[60px] border border-gray-200 p-3 rounded-md bg-gray-50">
                <template x-for="(tag, index) in goalTags" :key="index">
                    <div class="flex items-center justify-between p-2 bg-white border border-gray-200 rounded shadow-sm cursor-grab active:cursor-grabbing text-sm" :data-id="index">
                        <span class="text-gray-800 flex-grow mr-2" x-text="tag"></span>
                        <button @click="removeTag(index)" class="text-red-500 hover:text-red-700 ml-2 text-xs font-bold uppercase tracking-wider transition duration-150 ease-in-out">
                            Remove
                        </button>
                    </div>
                </template>
                <p x-show="goalTags.length === 0" class="text-gray-400 italic text-center py-3 text-sm">Add tags using the input above.</p>
            </div>

            <div class="flex items-center justify-between mb-4">
                 <button @click="synthesizeGoal()"
                        class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out disabled:opacity-50"
                        :disabled="goalTags.length === 0 || isSynthesizing">
                     <span x-show="!isSynthesizing">Synthesize Goal</span>
                     <span x-show="isSynthesizing">Synthesizing...</span>
                </button>
                <span x-show="synthesisError" class="text-red-600 text-sm font-medium" x-text="synthesisError"></span>
            </div>

            <div x-show="synthesizedGoal" x-transition class="mt-4 p-4 border border-yellow-300 rounded-md bg-yellow-50 text-yellow-800">
                <h3 class="font-semibold text-yellow-900 mb-1">Synthesized Goal:</h3>
                <p class="text-sm" x-text="synthesizedGoal"></p>
                {# TODO: Add button to "Set as Active Goal" which sends it via WebSocket? #}
                 <button class="mt-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-3 rounded-md text-xs transition duration-150 ease-in-out">
                    Set as Active Goal
                 </button>
            </div>
        </div>

        {# Simple Alpine.js example - Styled as a card #}
        <div x-data="{ count: 0 }" class="bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold mb-3 text-gray-700">Alpine.js Counter</h2>
            <p class="text-gray-600 mb-3">Current count: <span x-text="count" class="font-mono font-bold text-lg text-blue-600"></span></p>
            <button @click="count++" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out">
                Increment
            </button>
        </div>

    </div>

    {# Right Column #}
    <div class="space-y-6">

        {# Agent Status Section #}
        <div class="bg-white rounded-lg shadow-md p-6">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700 border-b pb-2">Agent Status</h2>
            <div class="max-h-96 overflow-y-auto space-y-3 pr-2">
                {# TODO: Fetch and display agent status dynamically from API or WebSocket #}
                <template x-for="i in 3" :key="i"> {# Placeholder loop #}
                    <div class="p-3 border border-gray-200 rounded bg-gray-50 shadow-sm">
                         <div class="flex justify-between items-center mb-1">
                            <span class="font-bold text-indigo-700 text-sm">Role: Placeholder {{ i }}</span>
                            <span class="px-2 py-0.5 rounded text-xs font-semibold uppercase tracking-wide bg-yellow-100 text-yellow-800">
                                Waiting
                            </span>
                        </div>
                        <div class="text-xs text-gray-500">ID: agent-{{ i }}</div>
                    </div>
                </template>
                 <p class="text-gray-500 italic text-sm">(Agent status will appear here)</p>
            </div>
        </div>

        {# Chat Section #}
        <div class="bg-white rounded-lg shadow-md p-6" x-data="chatApp()">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700 border-b pb-2">Chat / Goal Input</h2>

            {# Display connection status #}
            <p class="text-xs mb-3 font-medium" :class="wsStatus === 'Connected' ? 'text-green-600' : 'text-red-600'">
                WebSocket Status: <span x-text="wsStatus"></span>
            </p>

            {# Chat message display area #}
            <div class="h-80 overflow-y-auto border border-gray-200 rounded-md p-3 mb-4 bg-gray-50 space-y-3">
                 <template x-for="(msg, index) in messages" :key="index">
                    <div class="flex" :class="msg.type === 'user' ? 'justify-end' : 'justify-start'">
                        <div class="max-w-[80%] p-2 rounded-lg text-sm"
                             :class="msg.type === 'user' ? 'bg-blue-100 text-blue-900' : 'bg-gray-200 text-gray-800'">
                            <strong class="block mb-0.5" x-text="msg.sender + ':'"></strong>
                            <span x-html="msg.text"></span> {# Basic rendering, sanitize if needed #}
                         </div>
                     </div>
                 </template>
                 <p x-show="messages.length === 0" class="text-gray-400 italic text-center py-4 text-sm">Chat history will appear here.</p>
            </div>

            {# Input area #}
            <div class="flex">
                <textarea x-model="inputText" @keydown.enter.prevent="sendMessage()"
                          class="flex-grow border border-gray-300 rounded-l-md p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm resize-none" rows="3"
                          placeholder="Enter your project goal or chat message..."
                          :disabled="wsStatus !== 'Connected'"></textarea>
                <button @click="sendMessage()"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-r-md text-sm transition duration-150 ease-in-out disabled:opacity-50"
                        :disabled="wsStatus !== 'Connected' || !inputText.trim()">
                    Send
                </button>
            </div>
        </div>

    </div> {# End Right Column #}

</div> {# End Grid #}
            WebSocket Status: <span x-text="wsStatus"></span>
        </p>

        {# Chat message display area #}
        <div class="h-64 overflow-y-auto border rounded p-2 mb-3 bg-gray-50">
             <template x-for="(msg, index) in messages" :key="index">
                <div class="mb-2 p-2 rounded text-sm"
                     :class="msg.type === 'user' ? 'bg-blue-100 text-right ml-auto max-w-[80%]' : 'bg-gray-200 text-left mr-auto max-w-[80%]'">
                    <strong x-text="msg.sender + ':'"></strong>
                    <span x-html="msg.text"></span> {# Basic rendering, sanitize if needed #}
                 </div>
             </template>
             <p x-show="messages.length === 0" class="text-gray-500 italic">Chat history will appear here.</p>
        </div>

        {# Input area #}
        <div class="flex">
            <textarea x-model="inputText" @keydown.enter.prevent="sendMessage()"
                      class="flex-grow p-2 border rounded-l" rows="3"
                      placeholder="Enter your project goal or chat message..."
                      :disabled="wsStatus !== 'Connected'"></textarea>
            <button @click="sendMessage()"
                    class="px-4 py-2 bg-green-500 text-white rounded-r hover:bg-green-600 disabled:opacity-50"
                    :disabled="wsStatus !== 'Connected' || !inputText.trim()">
                Send
            </button>
        </div>
    </div>
</div>

<script>
    function chatApp() {
        return {
            ws: null,
            wsStatus: 'Disconnected',
            messages: [], // { type: 'user'/'veda'/'info', sender: 'You'/'Veda'/'System', text: '...' }
            inputText: '',
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            reconnectDelay: 3000, // ms

            init() {
                console.log('Chat app initializing...');
                this.connectWebSocket();

                // Keep Alpine component scope for event listeners
                const self = this;
                window.addEventListener('beforeunload', () => {
                    if (self.ws) {
                        console.log('Closing WebSocket connection on page unload.');
                        self.ws.close();
                    }
                });
            },

            connectWebSocket() {
                // Construct WebSocket URL (ws:// or wss://)
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
                console.log(`Attempting to connect to WebSocket: ${wsUrl}`);
                this.wsStatus = 'Connecting...';

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('WebSocket connection established.');
                    this.wsStatus = 'Connected';
                    this.reconnectAttempts = 0; // Reset attempts on successful connection
                     this.addMessage('info', 'System', 'Connected to Veda.');
                };

                this.ws.onmessage = (event) => {
                    console.log('WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        // TODO: Handle different message types based on `data.message_type`
                        if (data.message_type === 'Info') {
                             this.addMessage('info', 'System', data.payload.message || 'Received info');
                        } else if (data.message_type === 'ChatEcho') { // Example echo
                             this.addMessage('veda', 'Veda (Echo)', `Server received: ${data.payload.original}`);
                        } else {
                             // Assume it's a chat message from Veda for now
                             this.addMessage('veda', 'Veda', data.payload.message || JSON.stringify(data.payload));
                        }
                    } catch (e) {
                        console.error('Failed to parse WebSocket message or invalid format:', e);
                         this.addMessage('info', 'System', `Received raw data: ${event.data}`);
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.wsStatus = 'Error';
                     this.addMessage('info', 'System', 'WebSocket connection error.');
                    // Attempt to reconnect on error as well
                    this.handleReconnect();
                };

                this.ws.onclose = (event) => {
                    console.log('WebSocket connection closed:', event.code, event.reason);
                    this.wsStatus = 'Disconnected';
                    this.ws = null;
                     this.addMessage('info', 'System', `WebSocket disconnected: ${event.reason || 'No reason given'}`);
                    // Attempt to reconnect if not a clean close (e.g., server restart)
                    if (!event.wasClean && this.reconnectAttempts < this.maxReconnectAttempts) {
                         this.handleReconnect();
                    } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        console.warn('Max WebSocket reconnect attempts reached.');
                         this.addMessage('info', 'System', 'Could not reconnect to Veda.');
                    }
                };
            },

            handleReconnect() {
                this.reconnectAttempts++;
                const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts -1); // Exponential backoff
                console.log(`Attempting WebSocket reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay / 1000}s...`);
                 this.addMessage('info', 'System', `Attempting reconnect (${this.reconnectAttempts})...`);
                setTimeout(() => this.connectWebSocket(), delay);
            },

            sendMessage() {
                const text = this.inputText.trim();
                if (text && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    console.log('Sending message:', text);
                    // Send raw text for now, backend needs to parse
                    // TODO: Standardize message format (e.g., JSON) if needed
                    this.ws.send(text);
                    this.addMessage('user', 'You', text); // Add user message locally
                    this.inputText = '';
                } else {
                    console.warn('Cannot send message: WebSocket not connected or input is empty.');
                     this.addMessage('info', 'System', 'Cannot send message: Not connected.');
                }
            },

            addMessage(type, sender, text) {
                this.messages.push({ type, sender, text });
                // Auto-scroll chat window (optional)
                this.$nextTick(() => {
                    const chatWindow = this.$el.querySelector('.overflow-y-auto');
                    if (chatWindow) {
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                    }
                });
            }
        }
    }

    function goalTagApp() {
        return {
            goalTags: [], // Array of strings
            newTagInput: '',
            synthesizedGoal: '',
            isSynthesizing: false,
            synthesisError: '',
            sortable: null,

            init() {
                console.log('Goal tag app initializing...');
                // Load tags from localStorage if available
                const savedTags = localStorage.getItem('vedaGoalTags');
                if (savedTags) {
                    try {
                        this.goalTags = JSON.parse(savedTags);
                    } catch (e) {
                        console.error("Failed to parse saved goal tags:", e);
                        localStorage.removeItem('vedaGoalTags');
                    }
                }
                // Initialize SortableJS after Alpine renders the list
                this.$nextTick(() => this.initSortable());
            },

            initSortable() {
                if (this.sortable) {
                    this.sortable.destroy(); // Destroy previous instance if exists
                }
                const el = this.$refs.tagList;
                if (!el) {
                    console.error("Sortable target element not found");
                    return;
                }
                this.sortable = new Sortable(el, {
                    animation: 150,
                    ghostClass: 'bg-blue-100', // Class for the drop placeholder
                    onEnd: (evt) => {
                        // Update the Alpine data array order based on SortableJS reorder
                        const item = this.goalTags.splice(evt.oldIndex, 1)[0];
                        this.goalTags.splice(evt.newIndex, 0, item);
                        this.saveTags(); // Save new order
                    },
                });
            },

            addTag() {
                const tag = this.newTagInput.trim();
                if (tag) {
                    this.goalTags.push(tag);
                    this.newTagInput = '';
                    this.saveTags();
                    this.$nextTick(() => this.initSortable()); // Re-init sortable if list was empty
                }
            },

            removeTag(index) {
                this.goalTags.splice(index, 1);
                this.saveTags();
                 this.$nextTick(() => this.initSortable()); // Re-init sortable if list becomes empty
            },

            saveTags() {
                localStorage.setItem('vedaGoalTags', JSON.stringify(this.goalTags));
                this.synthesizedGoal = ''; // Clear synthesized goal when tags change
                this.synthesisError = '';
            },

            async synthesizeGoal() {
                if (this.goalTags.length === 0) return;

                this.isSynthesizing = true;
                this.synthesizedGoal = '';
                this.synthesisError = '';
                console.log("Synthesizing goal with tags:", this.goalTags);

                try {
                    const response = await fetch('/api/synthesize-goal', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ tags: this.goalTags }),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    this.synthesizedGoal = data.goal;
                    console.log("Synthesized goal:", this.synthesizedGoal);

                } catch (error) {
                    console.error('Error synthesizing goal:', error);
                    this.synthesisError = `Failed to synthesize goal: ${error.message}`;
                } finally {
                    this.isSynthesizing = false;
                }
            }
        }
    }
</script>

{% endblock %}
