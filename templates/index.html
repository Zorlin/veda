{% extends "base.html" %}

{% block content %}
<div class="bg-white shadow-md rounded p-6">
    <h1 class="text-2xl font-bold mb-4">{{ title }}</h1>
    <p class="mb-4">Welcome to the Veda Web Interface. Define your goals and monitor progress here.</p>

    {# Simple Alpine.js example #}
    <div x-data="{ count: 0 }" class="mt-4 p-4 border rounded">
        <h2 class="text-lg font-semibold">Alpine.js Counter</h2>
        <p>Current count: <span x-text="count" class="font-mono"></span></p>
        <button @click="count++" class="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
            Increment
        </button>
    </div>

    {# Goal Tag Management Section #}
    <div class="mt-6 p-4 bg-white rounded shadow" x-data="goalTagApp()">
        <h2 class="text-xl font-semibold mb-3 text-gray-700">Define Goal</h2>
        <p class="text-sm text-gray-600 mb-3">Add short goal fragments or tasks below. Drag to reorder, then synthesize into a full goal.</p>

        <div class="flex mb-3">
            <input type="text" x-model="newTagInput" @keydown.enter.prevent="addTag()"
                   placeholder="Add a goal fragment..."
                   class="flex-grow border rounded-l p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button @click="addTag()"
                    class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-r"
                    :disabled="!newTagInput.trim()">
                Add Tag
            </button>
        </div>

        <div x-ref="tagList" class="mb-3 space-y-2 min-h-[50px] border p-2 rounded bg-gray-50">
            <template x-for="(tag, index) in goalTags" :key="index">
                <div class="flex items-center justify-between p-2 bg-white border rounded shadow-sm cursor-grab active:cursor-grabbing" :data-id="index">
                    <span class="text-gray-800" x-text="tag"></span>
                    <button @click="removeTag(index)" class="text-red-500 hover:text-red-700 ml-2 text-xs font-semibold">
                        &times; REMOVE
                    </button>
                </div>
            </template>
            <p x-show="goalTags.length === 0" class="text-gray-400 italic text-center py-2">Add tags using the input above.</p>
        </div>

        <div class="flex items-center justify-between">
             <button @click="synthesizeGoal()"
                    class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded disabled:opacity-50"
                    :disabled="goalTags.length === 0 || isSynthesizing">
                 <span x-show="!isSynthesizing">Synthesize Goal</span>
                 <span x-show="isSynthesizing">Synthesizing...</span>
            </button>
            <span x-show="synthesisError" class="text-red-500 text-sm" x-text="synthesisError"></span>
        </div>


        <div x-show="synthesizedGoal" class="mt-4 p-3 border rounded bg-yellow-50 border-yellow-200">
            <h3 class="font-semibold text-gray-700 mb-1">Synthesized Goal:</h3>
            <p class="text-gray-800" x-text="synthesizedGoal"></p>
            {# TODO: Add button to "Set as Active Goal" which sends it via WebSocket? #}
        </div>
    </div>


    {# Placeholder for future UI components #}
    <div class="mt-6">
        <h2 class="text-xl font-semibold">Agent Status</h2>
        <p class="text-gray-600">(Agent status will appear here)</p>
        {# TODO: Fetch and display agent status dynamically #}
    </div>

    <div class="mt-6" x-data="chatApp()">
        <h2 class="text-xl font-semibold">Chat / Goal Input</h2>

        {# Display connection status #}
        <p class="text-sm mb-2" :class="wsStatus === 'Connected' ? 'text-green-600' : 'text-red-600'">
            WebSocket Status: <span x-text="wsStatus"></span>
        </p>

        {# Chat message display area #}
        <div class="h-64 overflow-y-auto border rounded p-2 mb-3 bg-gray-50">
             <template x-for="(msg, index) in messages" :key="index">
                <div class="mb-2 p-2 rounded text-sm"
                     :class="msg.type === 'user' ? 'bg-blue-100 text-right ml-auto max-w-[80%]' : 'bg-gray-200 text-left mr-auto max-w-[80%]'">
                    <strong x-text="msg.sender + ':'"></strong>
                    <span x-html="msg.text"></span> {# Basic rendering, sanitize if needed #}
                 </div>
             </template>
             <p x-show="messages.length === 0" class="text-gray-500 italic">Chat history will appear here.</p>
        </div>

        {# Input area #}
        <div class="flex">
            <textarea x-model="inputText" @keydown.enter.prevent="sendMessage()"
                      class="flex-grow p-2 border rounded-l" rows="3"
                      placeholder="Enter your project goal or chat message..."
                      :disabled="wsStatus !== 'Connected'"></textarea>
            <button @click="sendMessage()"
                    class="px-4 py-2 bg-green-500 text-white rounded-r hover:bg-green-600 disabled:opacity-50"
                    :disabled="wsStatus !== 'Connected' || !inputText.trim()">
                Send
            </button>
        </div>
    </div>
</div>

<script>
    function chatApp() {
        return {
            ws: null,
            wsStatus: 'Disconnected',
            messages: [], // { type: 'user'/'veda'/'info', sender: 'You'/'Veda'/'System', text: '...' }
            inputText: '',
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            reconnectDelay: 3000, // ms

            init() {
                console.log('Chat app initializing...');
                this.connectWebSocket();

                // Keep Alpine component scope for event listeners
                const self = this;
                window.addEventListener('beforeunload', () => {
                    if (self.ws) {
                        console.log('Closing WebSocket connection on page unload.');
                        self.ws.close();
                    }
                });
            },

            connectWebSocket() {
                // Construct WebSocket URL (ws:// or wss://)
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
                console.log(`Attempting to connect to WebSocket: ${wsUrl}`);
                this.wsStatus = 'Connecting...';

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('WebSocket connection established.');
                    this.wsStatus = 'Connected';
                    this.reconnectAttempts = 0; // Reset attempts on successful connection
                     this.addMessage('info', 'System', 'Connected to Veda.');
                };

                this.ws.onmessage = (event) => {
                    console.log('WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        // TODO: Handle different message types based on `data.message_type`
                        if (data.message_type === 'Info') {
                             this.addMessage('info', 'System', data.payload.message || 'Received info');
                        } else if (data.message_type === 'ChatEcho') { // Example echo
                             this.addMessage('veda', 'Veda (Echo)', `Server received: ${data.payload.original}`);
                        } else {
                             // Assume it's a chat message from Veda for now
                             this.addMessage('veda', 'Veda', data.payload.message || JSON.stringify(data.payload));
                        }
                    } catch (e) {
                        console.error('Failed to parse WebSocket message or invalid format:', e);
                         this.addMessage('info', 'System', `Received raw data: ${event.data}`);
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.wsStatus = 'Error';
                     this.addMessage('info', 'System', 'WebSocket connection error.');
                    // Attempt to reconnect on error as well
                    this.handleReconnect();
                };

                this.ws.onclose = (event) => {
                    console.log('WebSocket connection closed:', event.code, event.reason);
                    this.wsStatus = 'Disconnected';
                    this.ws = null;
                     this.addMessage('info', 'System', `WebSocket disconnected: ${event.reason || 'No reason given'}`);
                    // Attempt to reconnect if not a clean close (e.g., server restart)
                    if (!event.wasClean && this.reconnectAttempts < this.maxReconnectAttempts) {
                         this.handleReconnect();
                    } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        console.warn('Max WebSocket reconnect attempts reached.');
                         this.addMessage('info', 'System', 'Could not reconnect to Veda.');
                    }
                };
            },

            handleReconnect() {
                this.reconnectAttempts++;
                const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts -1); // Exponential backoff
                console.log(`Attempting WebSocket reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay / 1000}s...`);
                 this.addMessage('info', 'System', `Attempting reconnect (${this.reconnectAttempts})...`);
                setTimeout(() => this.connectWebSocket(), delay);
            },

            sendMessage() {
                const text = this.inputText.trim();
                if (text && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    console.log('Sending message:', text);
                    // Send raw text for now, backend needs to parse
                    // TODO: Standardize message format (e.g., JSON) if needed
                    this.ws.send(text);
                    this.addMessage('user', 'You', text); // Add user message locally
                    this.inputText = '';
                } else {
                    console.warn('Cannot send message: WebSocket not connected or input is empty.');
                     this.addMessage('info', 'System', 'Cannot send message: Not connected.');
                }
            },

            addMessage(type, sender, text) {
                this.messages.push({ type, sender, text });
                // Auto-scroll chat window (optional)
                this.$nextTick(() => {
                    const chatWindow = this.$el.querySelector('.overflow-y-auto');
                    if (chatWindow) {
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                    }
                });
            }
        }
    }

    function goalTagApp() {
        return {
            goalTags: [], // Array of strings
            newTagInput: '',
            synthesizedGoal: '',
            isSynthesizing: false,
            synthesisError: '',
            sortable: null,

            init() {
                console.log('Goal tag app initializing...');
                // Load tags from localStorage if available
                const savedTags = localStorage.getItem('vedaGoalTags');
                if (savedTags) {
                    try {
                        this.goalTags = JSON.parse(savedTags);
                    } catch (e) {
                        console.error("Failed to parse saved goal tags:", e);
                        localStorage.removeItem('vedaGoalTags');
                    }
                }
                // Initialize SortableJS after Alpine renders the list
                this.$nextTick(() => this.initSortable());
            },

            initSortable() {
                if (this.sortable) {
                    this.sortable.destroy(); // Destroy previous instance if exists
                }
                const el = this.$refs.tagList;
                if (!el) {
                    console.error("Sortable target element not found");
                    return;
                }
                this.sortable = new Sortable(el, {
                    animation: 150,
                    ghostClass: 'bg-blue-100', // Class for the drop placeholder
                    onEnd: (evt) => {
                        // Update the Alpine data array order based on SortableJS reorder
                        const item = this.goalTags.splice(evt.oldIndex, 1)[0];
                        this.goalTags.splice(evt.newIndex, 0, item);
                        this.saveTags(); // Save new order
                    },
                });
            },

            addTag() {
                const tag = this.newTagInput.trim();
                if (tag) {
                    this.goalTags.push(tag);
                    this.newTagInput = '';
                    this.saveTags();
                    this.$nextTick(() => this.initSortable()); // Re-init sortable if list was empty
                }
            },

            removeTag(index) {
                this.goalTags.splice(index, 1);
                this.saveTags();
                 this.$nextTick(() => this.initSortable()); // Re-init sortable if list becomes empty
            },

            saveTags() {
                localStorage.setItem('vedaGoalTags', JSON.stringify(this.goalTags));
                this.synthesizedGoal = ''; // Clear synthesized goal when tags change
                this.synthesisError = '';
            },

            async synthesizeGoal() {
                if (this.goalTags.length === 0) return;

                this.isSynthesizing = true;
                this.synthesizedGoal = '';
                this.synthesisError = '';
                console.log("Synthesizing goal with tags:", this.goalTags);

                try {
                    const response = await fetch('/api/synthesize-goal', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ tags: this.goalTags }),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    this.synthesizedGoal = data.goal;
                    console.log("Synthesized goal:", this.synthesizedGoal);

                } catch (error) {
                    console.error('Error synthesizing goal:', error);
                    this.synthesisError = `Failed to synthesize goal: ${error.message}`;
                } finally {
                    this.isSynthesizing = false;
                }
            }
        }
    }
</script>

{% endblock %}
